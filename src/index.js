// full-file: src/index.js
// Coordinator script: read jobs.txt -> fetch job pages -> create markdown draft -> commit to outbox -> notify Telegram with Build/Skip buttons.
//
// Expects these helper modules in src/:
// - playwright.js    -> exports fetchJob(url, opts) -> { title, company, location, description }
// - keywords.js      -> exports matchKeywords(description, resume) -> { score, matched, partial, missing, matchedBullets }
// - git-helper.js    -> exports commitOutbox(localPath) -> returns public URL or null
// - telegram.js      -> exports sendTelegram(text, inlineKeyboard) async
//
// Env vars:
// - TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID
// - GITHUB_REPOSITORY (optional, used for fallback URLs)
//
// Behavior:
// - If jobs.txt missing, tries to run alerts-reader (node src/alerts-reader.js) once then errors.
// - Uses a small concurrency worker to process lines.
// - Writes outbox/<company>-<title>-<jobid>.md and attempts to commit via git-helper.
// - Sends Telegram message with inline buttons: Build Resume | Skip
// - Robust error handling and short logs.

const fs = require('fs');
const path = require('path');

const { fetchJob } = require('./playwright');
const { matchKeywords } = require('./keywords');
const { commitOutbox } = require('./git-helper');
const { sendTelegram } = require('./telegram');

const JOBS_FILE = path.resolve('jobs.txt');
const RESUME_FILE = path.resolve('master_resume.json');
const OUTBOX_DIR = path.resolve('outbox');

const CONCURRENCY = Number(process.env.JOBBOT_CONCURRENCY || 3);
const PLAYWRIGHT_TIMEOUT_MS = Number(process.env.PLAYWRIGHT_TIMEOUT_MS || 60_000);

function slugify(input) {
  return (input || '')
    .toString()
    .toLowerCase()
    .replace(/\s+/g, '-')
    .replace(/[^a-z0-9\-]/g, '')
    .replace(/\-+/g, '-')
    .replace(/(^-|-$)/g, '')
    .slice(0, 120);
}

function extractLinkedInJobId(url) {
  if (!url) return null;
  const m = url.match(/\/jobs\/view\/(\d+)/);
  return m ? m[1] : null;
}

async function safeSendTelegram(text, inlineKeyboard = null) {
  try { return await sendTelegram(text, inlineKeyboard); }
  catch (e) { console.error('Telegram send failed:', e && e.message ? e.message : e); }
}

function buildMarkdown(job, match, url, title, company, jobId, location) {
  const lines = [];
  lines.push(`# ${title}`);
  lines.push(`**Company:** ${company}`);
  lines.push(`**Location:** ${location}`);
  lines.push(`**Job ID:** ${jobId}`);
  lines.push(`**URL:** ${url}`);
  lines.push('\n---\n');
  lines.push('## Extracted job description\n');
  lines.push(job.description ? `\`\`\`\n${job.description.trim()}\n\`\`\`` : '_No description found_');
  lines.push('\n## Match summary\n');
  lines.push(`- match score: ${match.score}`);
  lines.push(`- matched skills: ${Array.isArray(match.matched) ? match.matched.join(', ') : (match.matched || 'None')}`);
  lines.push(`- partial matches: ${Array.isArray(match.partial) ? match.partial.join(', ') : (match.partial || 'None')}`);
  lines.push(`- missing skills: ${Array.isArray(match.missing) ? match.missing.join(', ') : (match.missing || 'None')}`);
  lines.push('\n## Suggested bullets (from resume)\n');
  const bullets = match.matchedBullets || [];
  if (!bullets.length) lines.push('- _No direct bullets matched._');
  else bullets.forEach(b => lines.push(`- ${b}`));
  lines.push('\n---\n*Generated by JobBot ‚Äî draft built against the LinkedIn post above.*');
  return lines.join('\n');
}

function ensureJobsFile() {
  if (fs.existsSync(JOBS_FILE)) return;
  console.log('jobs.txt not found ‚Äî attempting to generate via src/alerts-reader.js (best-effort).');
  try { require('child_process').execSync('node src/alerts-reader.js', { stdio: 'inherit' }); } catch (e) { /* ignore */ }
  if (!fs.existsSync(JOBS_FILE)) {
    console.error('jobs.txt missing. Please provide jobs.txt in repo root (one search URL per line).');
    process.exit(1);
  }
}

async function processJobUrl(url, resume) {
  console.log('Processing', url);
  let job;
  try {
    job = await fetchJob(url, { timeout: PLAYWRIGHT_TIMEOUT_MS });
  } catch (err) {
    console.error('fetchJob failed for', url, err && err.message ? err.message : err);
    await safeSendTelegram(`‚ö†Ô∏è Failed to fetch job: ${url}\nError: ${err && err.message ? err.message : err}`);
    return { url, ok: false };
  }

  const jobId = extractLinkedInJobId(url) || `${Date.now()}`;
  const title = job.title || 'Job';
  const company = job.company || 'Company';
  const location = job.location || 'N/A';

  // send initial 'processing' notification (optional)
  // await safeSendTelegram(`üìÑ Processing job ‚Äî *${title}* @ *${company}*\nLocation: ${location}\nJob URL: ${url}`);

  let match;
  try { match = matchKeywords(job.description || '', resume || {}); }
  catch (e) { console.error('matchKeywords failed:', e && e.message ? e.message : e); match = { score: 0, matched: [], partial: [], missing: [], matchedBullets: [] }; }

  try {
    if (!fs.existsSync(OUTBOX_DIR)) fs.mkdirSync(OUTBOX_DIR, { recursive: true });
    const companySlug = slugify(company) || 'company';
    const titleSlug = slugify(title) || 'role';
    const filename = `${companySlug}-${titleSlug}-${jobId}.md`;
    const filepath = path.join(OUTBOX_DIR, filename);
    const md = buildMarkdown(job, match, url, title, company, jobId, location);
    fs.writeFileSync(filepath, md, 'utf8');

    let remoteUrl = null;
    try { remoteUrl = await commitOutbox(filepath); } catch (e) { console.error('commitOutbox error:', e && e.message ? e.message : e); }

    // fallback link construction
    const fallback = `https://github.com/${process.env.GITHUB_REPOSITORY || '<repo>'}/blob/outbox/outbox/${encodeURIComponent(filename)}`;
    const fileLink = remoteUrl || fallback;

    const finalMsg = `‚úÖ Job processed\nRole: *${title}*\nCompany: *${company}*\nMatch score: ${match.score}\nDraft: ${fileLink}`;

    // Inline buttons: Build | Skip
    const buttons = [
      [{ text: 'Build Resume', callback_data: `BUILD|${filename}` },
       { text: 'Skip', callback_data: `SKIP|${filename}` }]
    ];

    await safeSendTelegram(finalMsg, buttons);
    return { url, ok: true, file: filepath, filename, fileLink, score: match.score };
  } catch (e) {
    console.error('Error writing/committing draft for', url, e && e.message ? e.message : e);
    await safeSendTelegram(`‚ö†Ô∏è JobBot error processing ${url}\n${e && e.message ? e.message : e}`);
    return { url, ok: false };
  }
}

async function runWithConcurrency(items, workerFn, concurrency = 3) {
  const results = [];
  let idx = 0;
  const workers = new Array(Math.min(concurrency, items.length)).fill(null).map(async () => {
    while (true) {
      const i = idx++;
      if (i >= items.length) break;
      try { results[i] = await workerFn(items[i]); }
      catch (err) { results[i] = { error: err && err.message ? err.message : err }; }
    }
  });
  await Promise.all(workers);
  return results;
}

async function main() {
  ensureJobsFile();

  const lines = fs.readFileSync(JOBS_FILE, 'utf8')
    .split(/\r?\n/)
    .map(l => l.trim())
    .filter(Boolean);
  if (!lines.length) { console.log('jobs.txt contains no lines. Exiting.'); return; }

  if (!fs.existsSync(RESUME_FILE)) {
    console.error('master_resume.json not found at repo root. Please add your master_resume.json.');
    process.exit(1);
  }
  const resume = JSON.parse(fs.readFileSync(RESUME_FILE, 'utf8'));

  console.log(`Processing ${lines.length} job lines with concurrency ${CONCURRENCY}`);

  const results = await runWithConcurrency(lines, url => processJobUrl(url, resume), CONCURRENCY);

  const succeeded = results.filter(r => r && r.ok).length;
  const failed = results.length - succeeded;
  console.log(`Run complete. Success: ${succeeded}, Failed: ${failed}`);

  await safeSendTelegram(`üèÅ JobBot run complete. Processed ${results.length} jobs. Success: ${succeeded}, Failed: ${failed}`);

  process.exit(0);
}

main().catch(err => {
  console.error('Unexpected error in index.js', err && err.message ? err.message : err);
  process.exit(1);
});
